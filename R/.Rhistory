#NB geom_ribbon requires the df to have a y variable, although not used.
MHSBootPlot=ggplot(Pdf,aes(len))+
geom_line(data=Pdf,aes(x=len,y=pred))+
geom_ribbon(data=Pdf,aes(x=len,ymin=low,ymax=upp),alpha=0.2)+
xlab("Length (cm)")+ylab("Retention probability")+theme_bw()+
theme(axis.text=element_text(size=txt),axis.title=element_text(size=txt))+
theme(plot.margin = unit(c(0.75,0.5,0.25,0.5), "cm"))+
labs(tag ="(a)")+theme(plot.tag.position=c(0.15,1.1))+
theme(plot.tag = element_text(size = txt))
MHSBootPlot
#dev.off()
#Predicted proportions
Preds.lower=apply(BootPredsConv,2,quantile,prob=0.025,na.rm=T)
Preds.upper=apply(BootPredsConv,2,quantile,prob=0.975,na.rm=T)
Pdf=data.frame(len=lenseq,pred=PredsConv,low=Preds.lower,upp=Preds.upper)
#pdf("ConventionalSeln.pdf",height=3)
#NB geom_ribbon requires the df to have a y variable, although not used.
ConvBootPlot=ggplot(Pdf,aes(len))+
geom_line(data=Pdf,aes(x=len,y=pred))+
geom_ribbon(data=Pdf,aes(x=len,ymin=low,ymax=upp),alpha=0.2)+
xlab("Length (cm)")+ylab("Retention probability")+theme_bw()+
theme(axis.text=element_text(size=txt),axis.title=element_text(size=txt))+
theme(plot.margin = unit(c(0.75,0.5,0.25,0.5), "cm"))+
labs(tag ="(b)")+theme(plot.tag.position=c(0.15,1.1))+
theme(plot.tag = element_text(size = txt))
ConvBootPlot
#dev.off()
#Predicted proportions
Ratio=PredsMHS/(PredsMHS+PredsConv)
BootRatio=BootPredsMHS/(BootPredsMHS+BootPredsConv)
RatioMax=1
Preds.lower=apply(BootRatio,2,quantile,prob=0.025,na.rm=T)
Preds.upper=pmin(RatioMax,apply(BootRatio,2,quantile,prob=0.975,na.rm=T))
Pdf=data.frame(len=lenseq,pred=Ratio,low=Preds.lower,upp=Preds.upper)
#pdf("SelnRatio.pdf",height=3)
#NB geom_ribbon requires the df to have a y variable, although not used.
PropnBootPlot=ggplot(Pdf,aes(len))+
geom_line(data=Pdf,aes(x=len,y=pred))+
geom_ribbon(data=Pdf,aes(x=len,ymin=low,ymax=upp),alpha=0.2)+
xlab("Length (cm)")+ylab("Relative retention")+theme_bw()+ylim(c(0,1))+
theme(axis.text=element_text(size=txt),axis.title=element_text(size=txt))+
theme(plot.margin = unit(c(0.75,0.5,0.25,0.5), "cm"))+
labs(tag ="(c)")+theme(plot.tag.position=c(0.15,1.1))+
theme(plot.tag = element_text(size = txt))
PropnBootPlot
pdf("BootstrapPlots.pdf",height=5,width=4)
grid.arrange(MHSBootPlot,ConvBootPlot,PropnBootPlot,nrow=3)
dev.off()
L50.diff=Bootpars1[,1]/Bootpars1[,2]-Bootpars3[,1]/Bootpars3[,2]
SR.diff=2*log(30)*(1/Bootpars1[,2]-1/Bootpars3[,2])
summary(L50.diff); summary(SR.diff)
plot(L50.diff,SR.diff); abline(h=0,v=0)
source("SELECT.R")
source("SelnCurveDefinitions.R")
source("TrawlFuncs.R")
Clark=read.table("../inst/extdata/Clark113_20min.dat",head=T)
#Clark is a df in SELECT package
#Clark=read.table("../inst/extdata/Clark113_20min.dat",head=T) #NB: cover is in 2nd col
#Logistic
fitL=SELECT(Clark,dtype="cc")
Clark
StartValues
#' @export
StartValues=function(rtype,Data) {
CodendMean=mean(rep(Data[,1],Data[,3]))
CodendSd=sd(rep(Data[,1],Data[,3]))
b0=2*log(3)/CodendSd; a0=-b0*CodendMean
switch(substr(rtype,1,6),
"cc.log"={ c(a0,b0) },
"cc.ric"={ c(a0,b0,0) },
"ph.log"={ c(a0,b),0) },
"ph.ric"={ c(a0,b0,0,0) },
stop("Please provide a value of x0 (initial parameter values")
)
}
StartValues=function(rtype,Data) {
CodendMean=mean(rep(Data[,1],Data[,3]))
CodendSd=sd(rep(Data[,1],Data[,3]))
b0=2*log(3)/CodendSd; a0=-b0*CodendMean
switch(substr(rtype,1,6),
"cc.log"={ c(a0,b0) },
"cc.ric"={ c(a0,b0,0) },
"ph.log"={ c(a0,b0,0) },
"ph.ric"={ c(a0,b0,0,0) },
stop("Please provide a value of x0 (initial parameter values")
)
}
#Clark is a df in SELECT package
#Clark=read.table("../inst/extdata/Clark113_20min.dat",head=T) #NB: cover is in 2nd col
#Logistic
fitL=SELECT(Clark,dtype="cc")
ModelCheck(fitL,minE=1,las=1)
Estimates(fitL)
library(msm)
deltamethod
delatmethod=function (g, mean, cov, ses = TRUE)
{
cov <- as.matrix(cov)
n <- length(mean)
if (!is.list(g))
g <- list(g)
if ((dim(cov)[1] != n) || (dim(cov)[2] != n))
stop(paste("Covariances should be a ", n, " by ",
n, " matrix"))
syms <- paste("x", 1:n, sep = "")
for (i in 1:n) assign(syms[i], mean[i])
gdashmu <- t(sapply(g, function(form) {
as.numeric(attr(eval(deriv(form, syms)), "gradient"))
}))
new.covar <- gdashmu %*% cov %*% t(gdashmu)
if (ses) {
new.se <- sqrt(diag(new.covar))
new.se
}
else new.covar
}
deltamethod=function (g, mean, cov, ses = TRUE)
{
cov <- as.matrix(cov)
n <- length(mean)
if (!is.list(g))
g <- list(g)
if ((dim(cov)[1] != n) || (dim(cov)[2] != n))
stop(paste("Covariances should be a ", n, " by ",
n, " matrix"))
syms <- paste("x", 1:n, sep = "")
for (i in 1:n) assign(syms[i], mean[i])
gdashmu <- t(sapply(g, function(form) {
as.numeric(attr(eval(deriv(form, syms)), "gradient"))
}))
new.covar <- gdashmu %*% cov %*% t(gdashmu)
if (ses) {
new.se <- sqrt(diag(new.covar))
new.se
}
else new.covar
}
#Clark is a df in SELECT package
#Clark=read.table("../inst/extdata/Clark113_20min.dat",head=T) #NB: cover is in 2nd col
#Logistic
fitL=SELECT(Clark,dtype="cc")
ModelCheck(fitL,minE=1,las=1)
Estimates(fitL)
PlotCurves(fitL,plotlens=seq(19,56,0.1),las=1)
#Compare to old functions
ccfit(Clark[,c(1,3,2)],suff.big=1)
#Richards
fitR=SELECT(Clark,dtype="cc",stype="richards")
ModelCheck(fitR,minE=1,las=1)
Estimates(fitR);
PlotCurves(fitR,plotlens=seq(19,56,0.1))
#Compare to old functions
ccfit(Clark[,c(1,3,2)],x0=c(-30,1,0.6),type="rich",suff.big=1)
#Pope is a df in the SELECT package
#Pope=read.table("../inst/extdata/haddock.dat",head=T) #NB: control is in 2nd col
#Logistic
fitL=SELECT(Pope,dtype="ph")
Pope=read.table("../inst/extdata/haddock.dat",head=T) #NB: control is in 2nd col
#Logistic
#Pope is a df in the SELECT package
#Pope=read.table("../inst/extdata/haddock.dat",head=T) #NB: control is in 2nd col
#Logistic
fitL=SELECT(Pope,dtype="ph")
ModelCheck(fitL,minE=1,las=1)
Estimates(fitL)
PlotCurves(fitL,plotlens=seq(19,56,0.1),las=1)
#Compare to old functions
ttfit(Pope[,c(1,3,2)],suff.big=1)
#Fixed split, psplit=0.5
fitL2=SELECT(Pope,dtype="re",x0=c(30,2))
ModelCheck(fitL2,minE=1,las=1)
Estimates(fitL2)
ttfit(Pope[,c(1,3,2)],psplit=0.5,x0=c(-30,1,0.5),suff.big=1)
Estimates(fitL2)
fitL2
ttfit(Pope[,c(1,3,2)],psplit=0.5,x0=c(-30,1,0.5),suff.big=1)
fitL2=SELECT(Pope,dtype="re",x0=c(30,2))
ModelCheck(fitL2,minE=1,las=1)
Estimates(fitL2)
fitL2
fitL2=SELECT(Pope,dtype="re")
fitL2=SELECT(Pope,dtype="re",x0=c(-30,1))
ModelCheck(fitL2,minE=1,las=1)
Estimates(fitL2)
PlotCurves(fitL2,plotlens=seq(19,56,0.1),las=1)
ttfit(Pope[,c(1,3,2)],psplit=0.5,x0=c(-30,1,0.5),suff.big=1)
ttfit(Pope[,c(1,3,2)],psplit=0.5,x0=c(-30,1,0.5),suff.big=0)
fitR=SELECT(Pope,dtype="ph",stype="richards",,
penalty.func=function(theta) 0.01*theta[3]^2)
ModelCheck(fitR,minE=1,las=1)
Estimates(fitR);
PlotCurves(fitR,plotlens=seq(19,56,0.1))
#Compare to old functions
ttfit(Pope[,c(1,3,2)],x0=c(-30,1,0.5,1),type="rich",delta.pen=0.01,suff.big=1)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(30,2,0),rel.power=c(1,2),
penalty.func=function(theta) 0.01*theta[3]^2)
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
#Fixed split, psplit=2/3
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(1,2),
penalty.func=function(theta) 0.01*theta[3]^2)
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
PlotCurves(fitR2,plotlens=seq(19,56,0.1),las=1,standardize = T)
ttfit(Pope[,c(1,3,2)],psplit=2/3,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
ttfit
?optim
sqrt(.Machine$double.eps)
fitR2
ModelCheck(fitR2,minE=1,las=1)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(1,2),
penalty.func=function(theta) 0.01*theta[3]^2,
control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
#Fixed split, psplit=2/3
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(1,2),
penalty.func=function(theta) 0.00*theta[3]^2,
control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
PlotCurves(fitR2,plotlens=seq(19,56,0.1),las=1,standardize = T)
ttfit(Pope[,c(1,3,2)],psplit=2/3,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
fitR2
#Fixed split, psplit=2/3
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(1,2),
penalty.func=function(theta) 0.00*theta[3]^2,
control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(1,2),
penalty.func=function(theta) 0.00*theta[3]^2)
#control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
ttfit(Pope[,c(1,3,2)],psplit=2/3,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
ttfit
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0,0),rel.power=c(1,2),
penalty.func=function(theta) 0.00*theta[3]^2)
#control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
ttfit(Pope[,c(1,3,2)],psplit=2/3,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
fitL2
fitR
exp(0.315)
plogis(0.315)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0,0),rel.power=c(2,3),
penalty.func=function(theta) 0.01*theta[3]^2)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0,0),rel.power=c(2,3),
penalty.func=function(theta) 0.01*theta[3]^2)
#control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(2,3),
penalty.func=function(theta) 0.01*theta[3]^2)
#control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
PlotCurves(fitR2,plotlens=seq(19,56,0.1),las=1,standardize = T)
ttfit(Pope[,c(1,3,2)],psplit=0.6,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
Holt=read.table("../inst/extdata/holt.dat",head=F);
Meshsize=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
#Equal fishing power
pwr=rep(1,8)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Holt,dtype="re",stype="norm.loc",Meshsize,x0=c(60,4),rel.power=pwr)
Meshsize
fit=SELECT(Holt,dtype="re",stype="norm.loc",Meshsize=Meshsize,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
Holt=read.table("../inst/extdata/holt.dat",head=F);
Meshs=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
#Equal fishing power
pwr=rep(1,8)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Holt,dtype="re",stype="norm.loc",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="norm.sca",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
#Needs wide seln curve for x0
fit=SELECT(Holt,dtype="re",stype="gamma",Meshsize=Meshs,x0=c(10,5),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="logistic",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="logistic",Meshsize=Meshs,x0=c(-60,1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="richards",Meshsize=Meshs,x0=c(-60,1,0),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
Holt=read.table("../inst/extdata/holt.dat",head=F);
Meshs=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
#Equal fishing power
pwr=rep(1,8)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Holt,dtype="re",stype="norm.loc",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="norm.sca",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
#Needs wide seln curve for x0
fit=SELECT(Holt,dtype="re",stype="gamma",Meshsize=Meshs,x0=c(10,5),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="logistic",Meshsize=Meshs,x0=c(-60,1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="richards",Meshsize=Meshs,x0=c(-60,1,0),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="lognorm",Meshsize=Meshs,x0=c(log(60),0.1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="binorm.sca",Meshsize=Meshs,x0=c(55,4,65,4,2),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Holt,dtype="re",stype="bilognorm",Meshsize=Meshs,x0=c(4,0.2,4.2,0.1,2),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
Trammel=read.table("../inst/extdata/trammel.dat",head=F);
#Trammel=as.matrix(Trammel) #Needed only if a complete column of NA's
Meshsize=c(6.1,7.6,7.9,9.1,10.6,13)
#Equal fishing power (within each of the two expts)
pwr=rep(1,6)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshsize,x0=c(25,4),rel.power=pwr)
Trammel=read.table("../inst/extdata/trammel.dat",head=F);
#Trammel=as.matrix(Trammel) #Needed only if a complete column of NA's
Meshs=c(6.1,7.6,7.9,9.1,10.6,13)
#Equal fishing power (within each of the two expts)
pwr=rep(1,6)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshsize=Meshs,x0=c(25,4),rel.power=pwr)
Trammel=read.table("../inst/extdata/trammel.dat",head=F);
#Trammel=as.matrix(Trammel) #Needed only if a complete column of NA's
Meshs=c(6.1,7.6,7.9,9.1,10.6,13)
#Equal fishing power (within each of the two expts)
pwr=rep(1,6)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshsize=Meshs,x0=c(25,4),rel.power=pwr)
fit=SELECT(Trammel,dtype="re",stype="norm.sca",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
Trammel
nllhood=function(theta,Data,Meshsize,r,rel.power,penalty.func) {
lens=Data[,1]; Counts=Data[,-1]
rmatrix=outer(lens,Meshsize,r,theta)
rmatrix[is.na(Counts)]=0 #No fitted retention for NA counts
rmatrix=t(t(rmatrix)*rel.power)
phi=rmatrix/apply(rmatrix,1,sum,na.rm=TRUE)
nll=-sum(Counts[Counts>0]*log(phi[Counts>0]),na.rm=T)
#nll=sum(byrow_dmultinom(Counts,prob=phi,log=T))
nll=nll+penalty.func(theta)
return(nll) }
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Holt,dtype="re",stype="norm.sca",Meshsize=Meshs,x0=c(60,4),rel.power=pwr)
fit=SELECT(Trammel,dtype="re",stype="norm.sca",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
Trammel=read.table("../inst/extdata/trammel.dat",head=F);
#Trammel=as.matrix(Trammel) #Needed only if a complete column of NA's
Meshs=c(6.1,7.6,7.9,9.1,10.6,13)
#Equal fishing power (within each of the two expts)
pwr=rep(1,6)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="norm.sca",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="gamma",Meshs=Meshs,x0=c(5,5),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="lognorm",Meshs=Meshs,x0=c(log(25),0.1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="logistic",Meshs=Meshs,x0=c(-60,1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="logistic",Meshs=Meshs,x0=c(-30,1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit
mchoose=function(x,log=TRUE){
x=as.matrix(x)
if(ncol(x)==1) stop("x[] must have at least 2 columns")
rowN=apply(x,1,sum,na.rm=T)
const=0
for(i in 1:nrow(x)) const=const+lgamma(rowN[i]+1)-sum(lgamma(x[i,]+1),na.rm=T)
if (log) return(const)
else return(exp(const))
}
Trammel=read.table("../inst/extdata/trammel.dat",head=F);
#Trammel=as.matrix(Trammel) #Needed only if a complete column of NA's
Meshs=c(6.1,7.6,7.9,9.1,10.6,13)
#Equal fishing power (within each of the two expts)
pwr=rep(1,6)
#Or use this for fishing power proportional to meshsize
#pwr=Meshsize
par(mfrow=c(3,2),mar=c(4.1,4.1,1,1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="norm.sca",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="gamma",Meshs=Meshs,x0=c(5,5),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="lognorm",Meshs=Meshs,x0=c(log(25),0.1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="logistic",Meshs=Meshs,x0=c(-30,1),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
#fit=SELECT(Trammel,dtype="re",stype="richards",Meshsize,x0=c(70,4,0),rel.power=pwr)
#ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(40,90,0.1))
fit=SELECT(Trammel,dtype="re",stype="binorm.sca",Meshs=Meshs,x0=c(18.6,3.5,25,4,-2),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="bilognorm",Meshs=Meshs,x0=c(3,0.2,3.2,0.1,2),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="norm.loc",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
fit=SELECT(Trammel,dtype="re",stype="norm.sca",Meshs=Meshs,x0=c(25,4),rel.power=pwr)
ModelCheck(fit,minE=1); Estimates(fit); PlotCurves(fit,plotlens=seq(10,40,0.1))
Holt
save(list(Holt=Holt,Meshsize=Meshs),file="../data/Pope.RData")
list(Holt = Holt, Meshsize = Meshs)
Holt=read.table("../inst/extdata/holt.dat",head=F);
Meshs=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
list(Holt = Holt, Meshsize = Meshs)
Counts=read.table("../inst/extdata/holt.dat",head=F);
Meshsize=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
Holt=list(Counts=Holt,Meshsize=Meshsize)
save(Holt,file="../data/Pope.RData")
Pope=read.table("../inst/extdata/haddock.dat",head=T)
save(Pope,file="../data/Pope.RData")
Counts=read.table("../inst/extdata/holt.dat",head=F);
Meshsize=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
Holt=list(Counts=Holt,Meshsize=Meshsize)
save(Holt,file="../data/Holt.RData")
setwd("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT")
roxygen2::roxygenise()
rm(list=ls())
roxygen2::roxygenise()
ls()
remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
library(SELECT)
library(SELECT)
ls()
remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
install.packages("installr")
require(installr)
updateR()
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE)
remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
library(SELECT)
Pope
Holt
#Clark is a df in SELECT package
#Clark=read.table("../inst/extdata/Clark113_20min.dat",head=T) #NB: cover is in 2nd col
#Logistic
fitL=SELECT(Clark,dtype="cc")
ModelCheck(fitL,minE=1,las=1)
Estimates(fitL)
PlotCurves(fitL,plotlens=seq(19,56,0.1),las=1)
#Compare to old functions
ccfit(Clark[,c(1,3,2)],suff.big=1)
#Richards
fitR=SELECT(Clark,dtype="cc",stype="richards")
ModelCheck(fitR,minE=1,las=1)
Estimates(fitR);
PlotCurves(fitR,plotlens=seq(19,56,0.1))
#Compare to old functions
ccfit(Clark[,c(1,3,2)],x0=c(-30,1,0.6),type="rich",suff.big=1)
#Pope is a df in the SELECT package
#Pope=read.table("../inst/extdata/haddock.dat",head=T) #NB: control is in 2nd col
#Logistic
fitL=SELECT(Pope,dtype="ph")
ModelCheck(fitL,minE=1,las=1)
Estimates(fitL)
PlotCurves(fitL,plotlens=seq(19,56,0.1),las=1)
#Compare to old functions
ttfit(Pope[,c(1,3,2)],suff.big=1)
#Fixed split, psplit=0.5
fitL2=SELECT(Pope,dtype="re",x0=c(-30,1))
ModelCheck(fitL2,minE=1,las=1)
Estimates(fitL2)
PlotCurves(fitL2,plotlens=seq(19,56,0.1),las=1)
ttfit(Pope[,c(1,3,2)],psplit=0.5,x0=c(-30,1,0.5),suff.big=1)
#Richards
fitR=SELECT(Pope,dtype="ph",stype="richards",,
penalty.func=function(theta) 0.01*theta[3]^2)
ModelCheck(fitR,minE=1,las=1)
Estimates(fitR);
PlotCurves(fitR,plotlens=seq(19,56,0.1))
#Compare to old functions
ttfit(Pope[,c(1,3,2)],x0=c(-30,1,0.5,1),type="rich",delta.pen=0.01,suff.big=1)
#Fixed split, psplit=0.6
fitR2=SELECT(Pope,dtype="re",stype="richards",x0=c(-30,1,0),rel.power=c(2,3),
penalty.func=function(theta) 0.01*theta[3]^2)
#control=list(maxit=1000,reltol=1e-8,parscale=c(10,1,1)))
ModelCheck(fitR2,minE=1,las=1)
Estimates(fitR2)
PlotCurves(fitR2,plotlens=seq(19,56,0.1),las=1,standardize = T)
ttfit(Pope[,c(1,3,2)],psplit=0.6,x0=c(-30,1,0.5,1),type="rich",suff.big=1)
Counts=read.table("../inst/extdata/holt.dat",head=F);
Meshsize=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
Holt=list(Counts=Counts,Meshsize=Meshsize)
save(Holt,file="../data/Holt.RData")
setwd("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R")
Counts=read.table("../inst/extdata/holt.dat",head=F);
Meshsize=c(13.5,14,14.8,15.4,15.9,16.6,17.8,19)
Holt=list(Counts=Counts,Meshsize=Meshsize)
save(Holt,file="../data/Holt.RData")
