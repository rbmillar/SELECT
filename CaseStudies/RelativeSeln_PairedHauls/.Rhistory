# Chunk 38: RC-H13-031.5
predictGLM(CRAN.quasigfit, predCRAN.df)
# Chunk 39: RC-H13-031.6
predictGLM(CRAN.quasigfit, predCRAN.df,type="response")
# Chunk 1: RC-H13-000
source("../s20xNotesHelper.R")
## these are global knitr options and settings for the
## whole document
library(knitr)
library(s20x)
## comment = NA removes ## from all output lines
## prompt = TRUE means the console input prompt > is displayed
## tidy = TRUE means the code is properly spaced and tidied.
opts_chunk$set(comment = NA, size = "scriptsize", prompt = TRUE, tidy = TRUE)
#source("../predictGLM.R")
# Chunk 2: RC-H13-001
CRAN.df = read.table("Data/CRAN.txt", header=T)
CRAN.df
# Chunk 3: RC-H13-002
## One-by-two figure layout
par(mfrow=c(1,2))
## Scatter plot using raw y
plot(Number ~ Year, data = CRAN.df)
## Scatter plot using log y
plot(log(Number) ~ Year, data = CRAN.df)
# Chunk 4: RC-H13-003
trimPlot(Number ~ Year,
data = CRAN.df,
fileName = "figure/RC-H13-003A.pdf",
cex = 0.7,
x.lab = "Year",
y.lab = "Number",
fig.height = 2.5,
fig.width = 2.5)
trimPlot(log(Number) ~ Year,
data = CRAN.df,
fileName = "figure/RC-H13-003B.pdf",
cex = 0.7,
x.lab = "Year",
y.lab = "log(Number)",
fig.height = 2.5,
fig.width = 2.5)
# Chunk 5: RC-H13-004a
CRAN.fit = lm(log(Number) ~ Year, data = CRAN.df)
plot(CRAN.fit,which=1)
# Chunk 6: RC-H13-005a
trimPlot(CRAN.fit,
fileName = "figure/RC-H13-005a.pdf",
plotCommand = plot,
which=1,
x.lab="Fitted values",
y.lab="Residusals",
mai = c(0.5, 0.6, 0.1, 0.1),
fig.height = 1.75,
fig.width = 4)
# Chunk 7: RC-H13-004b
cooks20x(CRAN.fit)
# Chunk 8: RC-H13-005b
trimPlot(CRAN.fit,
fileName = "figure/RC-H13-005b.pdf",
plotCommand = cooks20x,
mai = c(0.5, 0.6, 0.1, 0.1),
fig.height = 1.75,
fig.width = 4)
# Chunk 9: RC-H13-006
trimPlot(log(Number) ~ Year,
data = CRAN.df[-3, ],
fileName = "figure/RC-H13-006.pdf",
cex = 0.7,
x.lab = "Year",
y.lab = "log(Number)",
fig.height = 2.5,
fig.width = 4.5,
addElements = list(
points(x = CRAN.df[3, 1], y = log(CRAN.df[3, 2]), col = "red", cex = 0.7, pch = 17)
))
# Chunk 10: RC-H13-007
summary(CRAN.fit)
# Chunk 11: RC-H13-008
slimSummary(CRAN.fit)
# Chunk 12: RC-H13-009
## Estimated annual multiplier
exp(CRAN.fit$coef["Year"])
## Confidence interval
exp(confint(CRAN.fit))
cis <- sprintf("%3.2f", exp(confint(CRAN.fit))[2, ])
# Chunk 13: RC-H13-010
predCRAN.df = data.frame(Year = 2017)
pred2017 = predict(CRAN.fit, predCRAN.df, interval = "confidence")
## Prediction on the log scale
pred2017
## Back-transform for the median of the number of submissions in 2017
exp(pred2017)
# Chunk 14: RC-H13-011
y=12; mu=9.61
(exp(-mu)*mu^y)/factorial(y)
# Chunk 15: RC-H13-012
dpois(12,9.61)
# Chunk 16: RC-H13-013
rpois(20,10)
# Chunk 17: RC-H13-014
barplot(dpois(0:12,3),names=0:12)
# Chunk 18: RC-H13-015
trimPlot(dpois(0:12, 3),
names = 0:12,
plotCommand = barplot,
fileName = "figure/RC-H13-015.pdf",
fig.height = 1.75,
fig.width = 4.5,
mai = c(0.4, 0.4, 0.1, 0.1))
# Chunk 19: RC-H13-016
round(dpois(0:20,3),6)
# Chunk 21: RC-H13-018
trimPlot(dpois(0:25, 10),
names = 0:25,
plotCommand = barplot,
fileName = "figure/RC-H13-018A.pdf",
fig.height = 1.25,
fig.width = 4.5,
mai = c(0.4, 0.4, 0.1, 0.1))
trimPlot(dpois(50:150, 100),
names = 50:150,
plotCommand = barplot,
fileName = "figure/RC-H13-018B.pdf",
fig.height = 1.25,
fig.width = 4.5,
mai = c(0.4, 0.4, 0.1, 0.1))
# Chunk 22: RC-H13-019
CRAN.gfit = glm(Number ~ Year, family = poisson, data = CRAN.df)
summary(CRAN.gfit)
# Chunk 23: RC-H13-020
slimSummary(CRAN.gfit)
# Chunk 24: RC-H13-021
plot(CRAN.gfit, which = 1)
# Chunk 25: RC-H13-022
trimPlot(CRAN.gfit,
which = 1,
fig.height = 1.9,
fig.width = 3.9,
cex = 0.7,
x.lab = "Fitted values",
y.lab = "Residuals",
fileName = "figure/RC-H13-022.pdf")
# Chunk 26: RC-H13-023
1 - pchisq(402.61,10)
# Chunk 27: RC-H13-024
CRAN.gfit= glm(Number~Year,family=poisson,data=CRAN.df)
summary(CRAN.gfit)
# Chunk 28: RC-H13-025
slimSummary(CRAN.gfit)
# Chunk 29: RC-H13-026
CRAN.quasigfit = glm(Number ~ Year, family = quasipoisson, data = CRAN.df)
summary(CRAN.quasigfit)
# Chunk 30: RC-H13-027
slimSummary(CRAN.quasigfit)
# Chunk 31: RC-H13-021c
plot(CRAN.quasigfit, which = 4)
# Chunk 32: RC-H13-022c
trimPlot(CRAN.quasigfit,
which = 4,
fig.height = 1.9,
fig.width = 3.9,
cex = 0.7,
x.lab = "Obs. number",
y.lab = "Cook's distance",
fileName = "figure/RC-H13-022c.pdf")
# Chunk 33: RC-H13-028
## The estimated annual multiplier
exp(CRAN.quasigfit$coef["Year"])
# Chunk 34: RC-H13-029
exp(confint(CRAN.quasigfit))
# Chunk 35: RC-H13-029b
cis2 <- sprintf("%3.2f", exp(confint(CRAN.quasigfit))[2, ])
# Chunk 36: RC-H13-030
exp(confint.default(CRAN.quasigfit))
# Chunk 37: RC-H13-031
pred2017.quasi=predict(CRAN.quasigfit, predCRAN.df, se.fit=TRUE)
# CI for log mean
lower = pred2017.quasi$fit-1.96*pred2017.quasi$se.fit
upper = pred2017.quasi$fit+1.96*pred2017.quasi$se.fit
#CI for mean value
pred2017.ci.mean=exp(c(lower, upper))
pred2017.ci.mean
# Chunk 38: RC-H13-031.5
predictGLM(CRAN.quasigfit, predCRAN.df)
# Chunk 39: RC-H13-031.6
predictGLM(CRAN.quasigfit, predCRAN.df,type="response")
#devtools::install_github("rbmillar/SELECT")
require(tidyverse)
require(mgcv)
require(SELECT)
require(readxl) #This package is installed with tidyverse
nsim=999 #For bootstrapping and permutation tests, set to >=999 in practice
#devtools::install_github("rbmillar/SELECT")
require(tidyverse)
require(mgcv)
require(SELECT)
require(readxl) #This package is installed with tidyverse
nsim=99 #For bootstrapping and permutation tests, set to >=999 in practice
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearB.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "35 square trawl")
#The "Day" variable is actually the unique haul-pair identifier
GearA.df = GearA.df |> rename(Haul=Day, nA=No.school, sfA=Sf.school)
GearB.df = GearB.df |> rename(Haul=Day, nB=No.school, sfB=Sf.school)
head(GearA.df)
View(GearA.df)
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearB.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "35 square trawl")
#The "Day" variable is actually the unique haul-pair identifier
GearA.df = GearA.df |> rename(Haul=Day, nA=No.school, sfA=Sf.school)
GearB.df = GearB.df |> rename(Haul=Day, nB=No.school, sfB=Sf.school)
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
dir()
setwd("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/CaseStudies/RelativeSeln_PairedHauls")
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearB.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "35 square trawl")
View(GearA.df)
#Merge the gears with the same identical haul-pair ID (i.e., twin tows)
Pairs.df = inner_join(GearA.df,GearB.df,by=c("Haul","CL"))
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearB.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "35 square trawl")
#The "Day" variable is actually the unique haul-pair identifier
GearA.df = GearA.df |> rename(Haul=Day, nA=No.school, sfA=Sf.school)
GearB.df = GearB.df |> rename(Haul=Day, nB=No.school, sfB=Sf.school)
#Merge the gears with the same identical haul-pair ID (i.e., twin tows)
Pairs.df = inner_join(GearA.df,GearB.df,by=c("Haul","CL"))
#Convert scaling factors to sampling fractions
Pairs.df = Pairs.df |>
transform(qA=1/sfA,qB=1/sfB) |> filter(CL>=5 & CL<=25)
head(Pairs.df)
dim(Pairs.df)
?write.csv
write.csv(Pairs.df,"Pairs.RData",row.names=F)
load("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/CaseStudies/RelativeSeln_PairedHauls/Pairs.RData")
ls()
knitr::opts_chunk$set(fig.height = 3.5)
#devtools::install_github("rbmillar/SELECT")
require(tidyverse)
require(mgcv)
require(SELECT)
require(readxl) #This package is installed with tidyverse
nsim=99 #For bootstrapping and permutation tests, set to >=999 in practice
GearA.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "32 square trawl")
GearB.df=read_excel("SchoolPrawnLenFreqs.xlsx", sheet = "35 square trawl")
#The "Day" variable is actually the unique haul-pair identifier
GearA.df = GearA.df |> rename(Haul=Day, nA=No.school, sfA=Sf.school)
GearB.df = GearB.df |> rename(Haul=Day, nB=No.school, sfB=Sf.school)
#Merge the gears with the same identical haul-pair ID (i.e., twin tows)
Pairs.df = inner_join(GearA.df,GearB.df,by=c("Haul","CL"))
#Convert scaling factors to sampling fractions
Pairs.df = Pairs.df |>
transform(qA=1/sfA,qB=1/sfB) |> filter(CL>=5 & CL<=25)
#write.csv(Pairs.df,"Pairs.RData",row.names=F)
names(Pairs.df)
vNames=c("CL","nA","nB")
qNames=c("qA","qB")
#Define the bootstrap prediction function
CLseq=seq(5,25,0.5) #Carapace lengths to use for predn
PrednFnc=function(data,var.names,q.names) {
SplineFit=SplineSELECT(data,var.names,q.names) #Using spline defaults
predict(SplineFit,newdata=data.frame(CL=CLseq),type="response") }
#Check that it works
predn=PrednFnc(Pairs.df,vNames,qNames)
#Plot predictions against observed proportions
Tots.df=Raw2Tots(Pairs.df,vNames,qNames) |>
transform(lgth=CL, y=nB/(nA+nB))
plot(y~CL,data=Tots.df,ylim=c(0,1),xlab="Carapace length (mm)",
ylab="Gear B catch share")
points(CLseq,predn,type="l")
abline(h=0.5,lty=3)
BootPreds=bootSELECT(Pairs.df,vNames,qNames,PrednFnc,haul="Haul",nsim=nsim,
paired=T,verbose=F) #Use verbose=T to see progress
BootPlot(BootPreds,CLseq,predn,Data=Tots.df) +
geom_hline(yintercept=0.5,linetype="dashed")
StatsFnc=function(data,var.names,q.names) {
SplineFit=SplineSELECT(data,var.names,q.names) #Defaults
SplineStatistics(SplineFit,MLS=15) }
#Check that it works
ObsStats=StatsFnc(Pairs.df,vNames,qNames)
ObsStats
PermStats=permSELECT(Pairs.df,vNames,qNames,StatsFnc,haul="Haul",nsim=nsim,
paired=T,verbose=F) #Use verbose=T to see progress
colnames(PermStats)=names(ObsStats) #To add column names to PermStats
Stat="LRT" #Likelihood ratio test for a length effect
cat("The observed",Stat,"is",ObsStats[Stat],"\n")
pval=permPval(ObsStats[Stat],PermStats[,Stat])
cat("The permutational p-value for a length effect is",pval,"\n")
Stat="EqualLRT" #LRT for equivalence, i.e., catch comparison=0.5 for all lengths
cat("The observed",Stat,"is",ObsStats[Stat],"\n")
pval=permPval(ObsStats[Stat],PermStats[,Stat])
cat("The permutational p-value for equivalence is",pval,"\n")
Stat="RatioPropnMLS" #Proportion of large fish in gear B compared to in gear A
cat("The observed",Stat,"is",ObsStats[Stat],"\n")
pval=permPval(ObsStats[Stat],PermStats[,Stat])
cat("The permutational p-value for equal propns of large fish is",pval,"\n")
require(MuMIn) #For MuMIn::dredge
options(na.action = "na.fail") #To ensure dredge terminates if there are NAs
#The default averaged-polynomial fit
PolyFit=PolySELECT(Pairs.df,vNames,qNames)
#The averaged-polynomial fit used by Herrmann et al. (2017)
HerrmannFit=PolySELECT(Pairs.df,vNames,qNames,q.ODadjust=F,quasi=F,All=T)
PolyPredn=predict(PolyFit$avg.fit,newdata=data.frame(CL=CLseq),
type="response")
HerrmannPredn=predict(HerrmannFit$avg.fit,newdata=data.frame(CL=CLseq),
type="response")
plot(y~CL,data=Tots.df,ylim=c(0,1),xlab="Carapace length (mm)",
ylab="Gear B catch share")
points(CLseq,predn,type="l",col="blue") #Spline
points(CLseq,PolyPredn,type="l",col="blue",lty=2) #PolySELECT
points(CLseq,HerrmannPredn,type="l",col="red",lty=2) #Herrmann et al. (2017)
legend("topleft",
legend=c("Spline","PolySELECT default","Herrmann et al. (2017)"),
col=c("blue","blue","red"),lty=c(1,2,2),bty="n")
abline(h=0.5,lty=3)
#' and `coverage.achieved` (the actual coverage achieved).
#' @details
#' The function finds the value of `eps` such that when bounds are computed as the
#' `eps` and `1-eps` quantiles at each length, approximately `coverage` proportion
#' of bootstrap curves are entirely contained within those bounds.
#'
#' The `limits` argument is useful when extreme lengths have high variability due to
#' sparse data, and you want to prevent these from unduly widening the confidence bands.
#' @export
#'
BootPlot2=function(BootPreds, lenseq, predn, Data=NULL, coverage=0.95, limits=NULL,
txt=8, xlab="Length (cm)", ylab="Catch proportion",
show.pointwise=FALSE) {
# Remove rows with NA values
valid.rows <- complete.cases(BootPreds)
BootPreds <- BootPreds[valid.rows, , drop=FALSE]
nsim <- nrow(BootPreds)
if(nsim < 20) warning("Few valid bootstrap replicates - simultaneous intervals may be unreliable")
# Determine which columns (lengths) to use for coverage calculation
if(is.null(limits)) {
use_cols <- seq_along(lenseq)
} else {
use_cols <- which(lenseq >= limits[1] & lenseq <= limits[2])
if(length(use_cols) == 0) stop("No lengths fall within specified limits")
}
# Function to compute coverage for a given eps
# Coverage = proportion of bootstrap curves entirely within [lower, upper] bounds
compute_coverage <- function(eps) {
lower <- apply(BootPreds, 2, quantile, prob=eps, na.rm=TRUE)
upper <- apply(BootPreds, 2, quantile, prob=1-eps, na.rm=TRUE)
# Check each bootstrap curve: is it entirely within bounds (for selected columns)?
within_bounds <- apply(BootPreds, 1, function(curve) {
all(curve[use_cols] >= lower[use_cols] & curve[use_cols] <= upper[use_cols])
})
mean(within_bounds)
}
# Binary search to find eps that achieves desired coverage
# eps=0 gives 100% coverage, eps=(1-coverage)/2 is the pointwise eps
# Simultaneous eps will always be smaller than pointwise eps
eps_low <- 0
eps_high <- (1 - coverage) / 2
target <- coverage
tol <- 0.0001
# Binary search
max_iter <- 50
for(i in 1:max_iter) {
eps_mid <- (eps_low + eps_high) / 2
cov_mid <- compute_coverage(eps_mid)
if(abs(cov_mid - target) < tol) {
break
}
# Coverage increases as eps decreases (bounds get wider)
if(cov_mid < target) {
# Need wider bounds, decrease eps
eps_high <- eps_mid
} else {
# Bounds too wide, increase eps
eps_low <- eps_mid
}
}
eps_final <- eps_mid
coverage_achieved <- cov_mid
# Compute final bounds
Preds.lower <- apply(BootPreds, 2, quantile, prob=eps_final, na.rm=TRUE)
Preds.upper <- apply(BootPreds, 2, quantile, prob=1-eps_final, na.rm=TRUE)
Pdf <- data.frame(len=lenseq, pred=predn, low=Preds.lower, upp=Preds.upper)
# Build the plot
BootGROB <- ggplot(data=Pdf, aes(len)) +
geom_ribbon(data=Pdf, aes(x=len, ymin=low, ymax=upp), alpha=0.2) +
geom_line(data=Pdf, aes(len, pred)) + ylim(0,1) +
xlab(xlab) + ylab(ylab) + theme_bw() +
theme(axis.text=element_text(size=txt), axis.title=element_text(size=txt)) +
theme(plot.margin = unit(c(0.75, 0.5, 0.25, 0.5), "cm"))
# Optionally add pointwise intervals as inner band
if(show.pointwise) {
pw_eps <- (1 - coverage) / 2
Preds.lower.pw <- apply(BootPreds, 2, quantile, prob=pw_eps, na.rm=TRUE)
Preds.upper.pw <- apply(BootPreds, 2, quantile, prob=1-pw_eps, na.rm=TRUE)
Pdf$low.pw <- Preds.lower.pw
Pdf$upp.pw <- Preds.upper.pw
BootGROB <- BootGROB +
geom_ribbon(data=Pdf, aes(x=len, ymin=low.pw, ymax=upp.pw), alpha=0.3)
}
if(!is.null(Data)) BootGROB <- BootGROB + geom_point(data=Data, aes(x=lgth, y=y))
# Return list with plot and diagnostics
list(plot=BootGROB,
eps=eps_final,
coverage.achieved=coverage_achieved,
pointwise.eps=(1-coverage)/2)
}
BootPlot(BootPreds,CLseq,predn,Data=Tots.df) +
geom_hline(yintercept=0.5,linetype="dashed")
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df) +
geom_hline(yintercept=0.5,linetype="dashed")
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df) +
geom_hline(yintercept=0.5,linetype="dashed")
X=BootPlot2(BootPreds,CLseq,predn,Data=Tots.df) +
geom_hline(yintercept=0.5,linetype="dashed")
X
BootPlot2
?break
BootPlot22(BootPreds,CLseq,predn,Data=Tots.df)
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df)
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df)
nsim=1000
BootPreds=bootSELECT(Pairs.df,vNames,qNames,PrednFnc,haul="Haul",nsim=nsim,
paired=T,verbose=F) #Use verbose=T to see progress
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df)
?missing
?uniroot
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T)
BootPlot2(BootPreds[1:100,],CLseq,predn,Data=Tots.df,show=T)
BootPlot2(BootPreds[1:99,],CLseq,predn,Data=Tots.df,show=T)
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T)
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=limits=c(10,20))
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(14,15))
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(14))
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(14))
head(BootPreds)
lenseq
CLseq
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(14,15))
BootPlot2(BootPreds[1:199,],CLseq,predn,Data=Tots.df,show=T,limits=c(14,14.5))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(14,14.5))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
quantile(1:10,prob=1.01)
compute_coverage <- function(eps) {
lower <- apply(BootPreds, 2, quantile, prob=eps, na.rm=TRUE)
upper <- apply(BootPreds, 2, quantile, prob=1-eps, na.rm=TRUE)
# Check each bootstrap curve: is it entirely within bounds (for selected columns)?
within_bounds <- apply(BootPreds, 1, function(curve) {
all(curve[use_cols] >= lower[use_cols] & curve[use_cols] <= upper[use_cols])
})
mean(within_bounds)
}
coverage=0.95
limits=range(CLse)
limits=range(CLseq)
limits
f=function(eps) compute_coverage(eps)-coverage
Target=uniroot(f,lower=0,upper=0.025)
if(is.null(limits)) {
use_cols <- seq_along(lenseq)
} else {
use_cols <- which(lenseq >= limits[1] & lenseq <= limits[2])
if(length(use_cols) == 0) stop("No lengths fall within specified limits")
}
lenseq=CLseq
} else {
if(is.null(limits)) {
use_cols <- seq_along(lenseq)
} else {
use_cols <- which(lenseq >= limits[1] & lenseq <= limits[2])
if(length(use_cols) == 0) stop("No lengths fall within specified limits")
}
f=function(eps) compute_coverage(eps)-coverage
Target=uniroot(f,lower=0,upper=0.025)
Target
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
f=function(eps) compute_coverage(eps)-coverage
Target=uniroot(f,lower=0,upper=0.025,tol=0.0001)
Target
f=function(eps) compute_coverage(eps)-coverage
Target=uniroot(f,lower=0,upper=0.025,tol=0.0001)
save.BootPreds=BootPreds
BootPreds=BootPreds[1:100,]
Target=uniroot(f,lower=0,upper=0.025,tol=0.0001)
Target
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
Target=uniroot(f,lower=0,upper=0.025,tol=1e-6)
Target
Target=uniroot(f,lower=0,upper=0.025,tol=1e-6)$f.root
BootPreds=save.BootPreds
Target=uniroot(f,lower=0,upper=0.025,tol=1e-6)$f.root
Target
uniroot(f,lower=0,upper=0.025,tol=1e-6)
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(1,40))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(7.5,22.5))
BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
Target
?uniroot
Target=uniroot(f,lower=0,upper=0.025,tol=1e-6)
Target
X=BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(10,20))
X$plot
X=BootPlot2(BootPreds,CLseq,predn,Data=Tots.df,show=T,limits=c(15,15)
)
X$plot
X
