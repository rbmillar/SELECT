xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos3,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
Df2$3strand=ifelse(df$Msize>150,1,0)
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
Df2$Twine3=ifelse(df$Msize>150,1,0)
head(Df2)
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
Df2$Twine3=ifelse(Df2$Msize>150,1,0)
GAMos=gam(y~Twine3+s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
gratia::draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
head(Df2)
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$Twine=ifelse(Df2$Msize>150,3,2)
#Difference in diameters is sqrt of ratio of number strands
Df2$os=log(Df2$Msize/sqrt(Df2$Twine/2)
GAMos=gam(y~Twine3+s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$Twine=ifelse(Df2$Msize>150,3,2)
#Difference in diameters is sqrt of ratio of number strands
Df2$os=log(Df2$Msize/sqrt(Df2$Twine/2))
GAMos=gam(y~Twine3+s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
gratia::draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
gratia::draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$Twine=ifelse(Df2$Msize>150,3,2)
#Difference in diameters is sqrt of ratio of number strands
Df2$os=log(Df2$Msize/sqrt(Df2$Twine/2))
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
gratia::draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
head(Df2)
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log( log(Df2$Msize) ) #Try power proportional to log(Msize). Better fit!
GAMos2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos2)
gratia::draw(GAMos2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
gratia::draw(GAMos2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 1
knitr::opts_chunk$set(cache=T)
BinormMaster="Bimodal-normal master selectivity curve from a fit
that assumes no knowledge of the population length distribution."
NoLenKnowMaster="Master selectivity curve from a GAM fit
that assumes no knowledge of the population length distribution."
# Chunk 2
#Packages tidyverse, gratia and SELECT need to be installed,
#and also the remotes package to install SELECT from GitHub.
#remotes::install_github("rbmillar/SELECT")
require(SELECT)
require(mgcv)
require(tidyverse)
require(gratia) #Provides the `draw` function
# Chunk 3: Trout data
data(Trout) #To load trout data from SELECT package
Trout
# Chunk 4: SELECT analyses
par(oma=c(0,0,0,0),mar=c(4,4,1,4))
Meshs=Trout$Meshsize
Counts=Trout$Counts
Vars=names(Counts)
SEL1=SELECT(Counts,Vars,dtype="dc",stype="norm.loc",Meshsize=Meshs)
AIC1=AIC(SEL1,type="Poisson")
SEL2=SELECT(Counts,Vars,dtype="dc",stype="normal",Meshsize=Meshs)
AIC2=AIC(SEL2,type="Poisson")
SEL3=SELECT(Counts,Vars,dtype="dc",stype="gamma",Meshsize=Meshs)
AIC3=AIC(SEL3,type="Poisson")
SEL4=SELECT(Counts,Vars,dtype="dc",stype="lognorm",Meshsize=Meshs)
AIC4=AIC(SEL4,type="Poisson")
SEL5=SELECT(Counts,Vars,dtype="dc",stype="binormal",Meshsize=Meshs)
AIC5=AIC(SEL5,type="Poisson")
SEL6=SELECT(Counts,Vars,dtype="dc",stype="bilognorm",Meshsize=Meshs)
AIC6=AIC(SEL6,type="Poisson")
cat("Poisson AICs are",AIC1,AIC2,AIC3,AIC4,AIC5,AIC6)
GOF.stats=ModelCheck(SEL5,print.out=F)$gof #Draws residual plot
GOF.stats
1-pchisq(80.55,67)
# Chunk 5: BinormMaster
par(mar=c(4,4,1,4))
plot(SEL5,ylab="Master curve")
# Chunk 6: Pivot longer
#Pivot longer
colnames(Counts)[-1]=Trout$Meshsize
Df=pivot_longer(Counts,cols=!lgth,values_to="y",names_to="Msize")
Df$Msize=as.numeric(Df$Msize)
Df$v=Df$lgth/Df$Msize
cat("The dataset has",nrow(Df),"rows\n")
head(Df) #A peek at the first few rows
# Chunk 7: NoLenKnowMaster
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,2))
GAM1=gam(y~as.factor(lgth)+s(v,bs="cr",k=5),
family=poisson,data=Df,method="ML")
AIC(GAM1)
draw(GAM1,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 8: Full GAM
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
GAM2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df,method="ML")
AIC(GAM2)
draw(GAM2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAM2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 9: Parametric vs GAM comparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
lgth.seq=seq(min(Df$lgth),max(Df$lgth),len=100)
v.seq=seq(min(Df$v),max(Df$v),len=100)
SEL.r0=PlotCurves(SEL5,plotlens=lgth.seq)
GAM1.r0=exp( predict(GAM1,newdata=data.frame(lgth=438,v=v.seq),terms="s(v)") )
GAM2.r0=exp( predict(GAM2,newdata=data.frame(lgth=438,v=v.seq),terms="s(v)") )
#X1=plot(GAM1,select=0) #Uses 100 pts by default
#v.seq=X1[[1]]$x
#r=exp(X1[[1]]$fit)
plot(SEL.r0$v,SEL.r0$r,type="l",lty=1,
xlab="Length/Meshsize",ylab="Master curve")
points(v.seq,GAM1.r0/max(GAM1.r0),type="l",lty=2)
points(v.seq,GAM2.r0/max(GAM2.r0),type="l",lty=3)
legend("topright",
legend=c("Parametric","factor(lgth)","s(lgth)"),lty=1:3)
# Chunk 10
Counts2=rbind(c(363,0,0,0,0,0),
c(388,0,0,0,0,0),
c(415,0,0,0,0,0),
Counts,
c(888,0,0,0,0,0),
c(913,0,0,0,0,0),
c(938,0,0,0,0,0))
#Pivot longer
Df2=pivot_longer(Counts2,cols=!lgth,values_to="y",names_to="Msize")
Df2$Msize=as.numeric(Df2$Msize)
Df2$v=Df2$lgth/Df2$Msize
cat("The zero-extended dataset has",nrow(Df2),"rows\n")
head(Df2) #A peek at the first few rows
# Chunk 11: Full GAM zero extended
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
GAM2.2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML")
AIC(GAM2.2)
draw(GAM2.2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAM2.2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 12: Extra zeros comparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
lgth.seq=seq(min(Df2$lgth),max(Df2$lgth),len=100)
v.seq=seq(min(Df2$v),max(Df2$v),len=100)
NewData=data.frame(lgth=lgth.seq,v=v.seq) #This works, since selecting term
GAM2.M=exp( predict(GAM2,newdata=NewData,terms="s(v)") )
GAM2.2.M=exp( predict(GAM2.2,newdata=NewData,terms="s(v)") )
GAM2.lgth=exp( predict(GAM2,newdata=NewData,terms="s(lgth)") )
GAM2.2.lgth=exp( predict(GAM2.2,newdata=NewData,terms="s(lgth)") )
plot(v.seq,GAM2.M/max(GAM2.M),type="l",lty=1,
xlab="Length/Meshsize",ylab="Master curve")
points(v.seq,GAM2.2.M/max(GAM2.2.M),type="l",lty=2)
legend("topright",
legend=c("No extra 0's","Extra 0's"),lty=1:2)
plot(lgth.seq,GAM2.lgth/max(GAM2.lgth),type="l",lty=1,
xlab="Length",ylab="Relative distribution")
points(lgth.seq,GAM2.2.lgth/max(GAM2.2.lgth),type="l",lty=2)
legend("topright",
legend=c("No extra 0's","Extra 0's"),lty=1:2)
# Chunk 13: Power propn to mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 14: Power propn to mesh to twine ratio
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$Twine=ifelse(Df2$Msize>150,3,2)
#Difference in diameters is sqrt of ratio of number strands
Df2$os=log(Df2$Msize/sqrt(Df2$Twine/2))
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 15: Power propn to log mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log( log(Df2$Msize) ) #Try power proportional to log(Msize). Better fit!
GAMos2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos2)
draw(GAMos2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 16: Power propn to exp mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=Df2$Msize/100 #Divide by 100 for numerical stability
GAMos3=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos3)
draw(GAMos3,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos3,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 17: Power comparison of encounter length distn
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1))
X0=plot(GAM2.2,select=0)
X1=plot(GAMos,select=0)
X2=plot(GAMos2,select=0)
X3=plot(GAMos3,select=0)
lgth.seq=X0[[1]]$x
plot(lgth.seq,exp(X0[[1]]$fit),type="l",lty=1,
xlab="Length",ylab="Relative abundance")
points(lgth.seq,exp(X1[[1]]$fit),type="l",lty=2)
points(lgth.seq,exp(X2[[1]]$fit),type="l",lty=3)
points(lgth.seq,exp(X3[[1]]$fit),type="l",lty=4)
legend("topright",
legend=c("equal","meshsize","log(meshsize)","exp(meshsize"),lty=1:4)
# Chunk 18: Power comparison of master selectivity
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1))
X0=plot(GAM2.2,select=0)
X1=plot(GAMos,select=0)
X2=plot(GAMos2,select=0)
X3=plot(GAMos3,select=0)
v.seq=X0[[2]]$x
plot(v.seq,exp(X0[[2]]$fit),type="l",lty=1,
xlab="Length/Meshsize",ylab="Master curve")
points(v.seq,exp(X1[[2]]$fit),type="l",lty=2)
points(v.seq,exp(X2[[2]]$fit),type="l",lty=3)
points(v.seq,exp(X3[[2]]$fit),type="l",lty=4)
legend("topright",
legend=c("equal","meshsize","log(meshsize)","exp(meshsize"),lty=1:4)
XX=draw(GAM2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
XX
Trout
?PlotCurves
ls()
predict(SEL5)
predict(SEL5,plotlens=lgth.seq)
predict(SEL5,lgth.seq)
PLotCurves
PlotCurves
SEL.r0=PlotCurves(SEL5,plotlens=lgth.seq,plot.out=F)
SEL.r0
PkgName="SELECT"
#PkgName="SHOUtoolkit"
#Create package folder structure (and opens 2nd RStudio for the project)
#usethis::create_package(PkgName)
setwd(paste0("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/",PkgName))
devtools::install( paste0("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/",PkgName) )
# Chunk 1: Figure captions
Supp=F
knitr::opts_chunk$set(fig.height=2.5,cache=T)
ResidPlot="Bubble plot of the deviance residuals from the bimodal normal
fit. Filled and open circles indicate positive and negative residuals,
respectively. Bubble diameter is proportion to the magnitude of the
residual."
BinormMaster="Bimodal-normal master selectivity curve from a fit
that assumes no knowledge of the population length distribution."
NoLenKnowMaster="Master selectivity curve from a GAM fit
that assumes no knowledge of the population length distribution."
LenDistn="Estimated population length distribution from a GAM fit that assumes
the population length distribution is a smooth function of length."
SelnComparison="Master selectivity curves from the parametric bimodal normal fit,
GAM with length as a factor (no knowledge of length distribution),
and GAM with length as a smooth function of length"
ZerosLenDistn="Estimated population length distribution from a GAM fit to
data that have been extended with zeros."
ZerosSelnComparison="Comparison of estimated selectivity curves
with or without extra zeros."
ZerosLenDistnComparison="Comparison of estimated population length distributions
with or without extra zeros."
ZerosLenDistnComparison="Comparison of estimated population length distributions
under different fishing power scenarios. The equal power and proportional to
mesh size fits are identical. Also shown are power proportional to the ratio of
mesh size to twine diameter, proportional to log of mesh size,
and proportional to exponent of mesh size."
PowerSelnComparison="Comparison of estimated selectivity curves
under different fishing power scenarios."
# Chunk 2
#Packages tidyverse, gratia and SELECT need to be installed,
#and also the remotes package to install SELECT from GitHub.
#remotes::install_github("rbmillar/SELECT")
require(SELECT)
require(mgcv)
require(tidyverse)
require(gratia) #Provides the `draw` function
# Chunk 3: Trout data
data(Trout) #To load trout data from SELECT package
Trout
# Chunk 4: Set variable names
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
Meshs=Trout$Meshsize
Counts=Trout$Counts
Vars=names(Counts)
# Chunk 5: SELECT analyses
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
SEL1=SELECT(Counts,Vars,dtype="dc",stype="norm.loc",Meshsize=Meshs)
AIC1=AIC(SEL1,type="Poisson")
SEL2=SELECT(Counts,Vars,dtype="dc",stype="normal",Meshsize=Meshs)
AIC2=AIC(SEL2,type="Poisson")
SEL3=SELECT(Counts,Vars,dtype="dc",stype="gamma",Meshsize=Meshs)
AIC3=AIC(SEL3,type="Poisson")
SEL4=SELECT(Counts,Vars,dtype="dc",stype="lognorm",Meshsize=Meshs)
AIC4=AIC(SEL4,type="Poisson")
SEL5=SELECT(Counts,Vars,dtype="dc",stype="binormal",Meshsize=Meshs)
AIC5=AIC(SEL5,type="Poisson")
SEL6=SELECT(Counts,Vars,dtype="dc",stype="bilognorm",Meshsize=Meshs)
AIC6=AIC(SEL6,type="Poisson")
cat("Poisson AICs are",AIC1,AIC2,AIC3,AIC4,AIC5,AIC6)
GOF.stats=ModelCheck(SEL5,print.out=F)$gof
GOF.stats
cat("The goodness of fit test p-value is",1-pchisq(80.55,67))
# Chunk 6: ResidPlot
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
SEL5=SELECT(Counts,Vars,dtype="dc",stype="binormal",Meshsize=Meshs)
ModelCheck(SEL5,print.out=F)
# Chunk 7: BinormMaster
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
plot(SEL5,ylab="Master curve")
# Chunk 8: Pivot longer
#Pivot longer
colnames(Counts)[-1]=Trout$Meshsize
Df=pivot_longer(Counts,cols=!lgth,values_to="y",names_to="Msize")
Df=data.frame(Df)
Df$Msize=as.numeric(Df$Msize)
Df$v=Df$lgth/Df$Msize
cat("The dataset Df has",nrow(Df),"rows\n")
# Chunk 9: Peek at Df
head(Df) #A peek at the first few rows
# Chunk 10: NoLenKnowMaster
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,2))
GAM1=gam(y~as.factor(lgth)+s(v,bs="cr",k=5),
family=poisson,data=Df,method="ML")
draw(GAM1,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 11
AIC(GAM1)
# Chunk 12: LenDistn
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
GAM2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df,method="ML")
draw(GAM2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
# Chunk 13
AIC(GAM2)
# Chunk 14: SelnComparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
lgth.seq=seq(min(Df$lgth),max(Df$lgth),len=100)
v.seq=seq(min(Df$v),max(Df$v),len=100)
GAM1.r0=exp( predict(GAM1,newdata=data.frame(lgth=438,v=v.seq),terms="s(v)") )
GAM2.r0=exp( predict(GAM2,newdata=data.frame(lgth=438,v=v.seq),terms="s(v)") )
PlotCurves(SEL5,plotlens=lgth.seq,ylab="Master curve")
points(v.seq,GAM1.r0/max(GAM1.r0),type="l",lty=2)
points(v.seq,GAM2.r0/max(GAM2.r0),type="l",lty=3,lwd=1.5)
legend("topright",
legend=c("Bimodal","factor(lgth)","s(lgth)"),lty=1:3)
# Chunk 15
Counts2=rbind(c(363,0,0,0,0,0),
c(388,0,0,0,0,0),
c(415,0,0,0,0,0),
Counts,
c(888,0,0,0,0,0),
c(913,0,0,0,0,0),
c(938,0,0,0,0,0))
#Pivot longer
Df2=pivot_longer(Counts2,cols=!lgth,values_to="y",names_to="Msize")
Df2$Msize=as.numeric(Df2$Msize)
Df2$v=Df2$lgth/Df2$Msize
cat("The zero-extended dataset has",nrow(Df2),"rows\n")
head(Df2) #A peek at the first few rows
# Chunk 16: ZerosLenDistn
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
GAM2.2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML")
draw(GAM2.2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
# Chunk 17
AIC(GAM2.2)
draw(GAM2.2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 18: Extra zeros comparison
lgth.seq=seq(min(Df2$lgth),max(Df2$lgth),len=100)
v.seq=seq(min(Df2$v),max(Df2$v),len=100)
NewData=data.frame(lgth=lgth.seq,v=v.seq) #This works, since selecting term
GAM2.M=exp( predict(GAM2,newdata=NewData,terms="s(v)") )
GAM2.2.M=exp( predict(GAM2.2,newdata=NewData,terms="s(v)") )
GAM2.lgth=exp( predict(GAM2,newdata=NewData,terms="s(lgth)") )
GAM2.2.lgth=exp( predict(GAM2.2,newdata=NewData,terms="s(lgth)") )
# Chunk 19: ZerosSelnComparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
plot(v.seq,GAM2.M/max(GAM2.M),type="l",lty=1,
xlab="Length/Meshsize",ylab="Master curve")
points(v.seq,GAM2.2.M/max(GAM2.2.M),type="l",lty=2)
legend("topright",
legend=c("No extra 0's","Extra 0's"),lty=1:2)
# Chunk 20: ZerosLenDistnComparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1),las=1)
plot(lgth.seq,GAM2.lgth/max(GAM2.lgth),type="l",lty=1,
xlab="Length",ylab="Relative distribution")
points(lgth.seq,GAM2.2.lgth/max(GAM2.2.lgth),type="l",lty=2)
legend("topright",
legend=c("No extra 0's","Extra 0's"),lty=1:2)
# Chunk 21: Power propn to mesh size
#Fishing power proportional to mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log(Df2$Msize) #Same fit as from assuming equal power fit
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 22: Power propn to mesh to twine ratio
#Fishing power proportional to ratio of mesh size to twine  diameter
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$NumThreads=ifelse(Df2$Msize>=152,3,2)
#Difference in diameters is sqrt of ratio of number strands
Df2$os=log(Df2$Msize/sqrt(Df2$NumThreads))
GAMos=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos)
draw(GAMos,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 23: Power propn to log mesh size
#Fishing power proportional to log of mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=log( log(Df2$Msize) ) #Try power proportional to log(Msize). Better fit!
GAMos2=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos2)
draw(GAMos2,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos2,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 24: Power propn to exp mesh size
#Fishing power proportional to exp(mesh size
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(2,1))
Df2$os=Df2$Msize/100 #Divide by 100 for numerical stability
GAMos3=gam(y~s(lgth,bs="cr",k=7)+s(v,bs="cr",k=5),
family=poisson,data=Df2,method="ML",offset=os)
AIC(GAMos3)
draw(GAMos3,select="s(lgth)",fun=exp,
xlab="Length (mm)",ylab="Relative distribution")
draw(GAMos3,select="s(v)",fun=exp,
xlab="length/meshsize",ylab="Master curve")
# Chunk 25: PowerLenDistnComparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1))
X0=plot(GAM2.2,select=0)
X1=plot(GAMos,select=0)
X2=plot(GAMos2,select=0)
X3=plot(GAMos3,select=0)
lgth.seq=X0[[1]]$x
plot(lgth.seq,exp(X0[[1]]$fit),type="l",lty=1,
xlab="Length",ylab="Relative abundance")
points(lgth.seq,exp(X1[[1]]$fit),type="l",lty=2)
points(lgth.seq,exp(X2[[1]]$fit),type="l",lty=3)
points(lgth.seq,exp(X3[[1]]$fit),type="l",lty=4)
legend("topright",
legend=c("equal","meshsize","log(meshsize)","exp(meshsize"),lty=1:4)
# Chunk 26: PowerSelnComparison
par(oma=c(0,0,0,0),mar=c(4,4,1,4),mfrow=c(1,1))
X0=plot(GAM2.2,select=0)
X1=plot(GAMos,select=0)
X2=plot(GAMos2,select=0)
X3=plot(GAMos3,select=0)
v.seq=X0[[2]]$x
plot(v.seq,exp(X0[[2]]$fit),type="l",lty=1,
xlab="Length/Meshsize",ylab="Master curve")
points(v.seq,exp(X1[[2]]$fit),type="l",lty=2)
points(v.seq,exp(X2[[2]]$fit),type="l",lty=3)
points(v.seq,exp(X3[[2]]$fit),type="l",lty=4)
legend("topright",
legend=c("equal","ratio","log(meshsize)","exp(meshsize"),lty=1:4)
purl("ApplicationTrout.Rnw")
knitr::purl("ApplicationTrout.Rnw")
pwd()
cwd()
ls()
dir()
getwd()
