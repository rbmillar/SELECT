llhoods=summStats[,c("null.l","model.l","full.l")]
cat("\nLog-likelihoods:\n")
print(llhoods)
cat("\nFit statistics\n")
GOF=summStats[,c("Deviance","Pearson.chisq","dof","Deviance.CF","Pearson.CF")]
print(GOF)
cat("\nEstimates\n")
print(Estimates(obj))
list(Call=obj$Call,llhoods=llhoods,GOF=GOF)
}
summary(Fit1)
summary.SELECT=function(obj) {
cat("Call:",deparse(obj$Call),"\n")
Estimates(obj)
summStats=ModelCheck(obj,print.out=F,plots=c(F,F))$stats
llhoods=summStats[,c("null.l","model.l","full.l")]
cat("\nLog-likelihoods:\n")
print(llhoods)
cat("\nFit statistics\n")
GOF=summStats[,c("Deviance","Pearson.chisq","dof","Deviance.CF","Pearson.CF")]
print(GOF)
cat("\nEstimates\n")
print(Estimates(obj))
invisible(list(Call=obj$Call,llhoods=llhoods,GOF=GOF))
}
summary(Fit1)
PlotCurves
Fit1=SELECT2(Stow.df,var.names=V.names,q.names=sampfracs)
coef(Fit1)
summary(Fit1)
par(mfrow=c(1,2))
plot(Fit1)
?predict.lm
ModelCheck(Fit1)
ModelCheck(Fit1)[]
View(ModelCheck)
View(PlotCurves)
PlotCurves(Fit1)
View(PlotCurves)
lenseq
lenseq=1:10
class(lenseq)
typeof(lenseq)
class(Tots.df)
is.vector(lenseq)
is.vector(Tots.df)
PlotCurves(Fit1,plotlens=newdata,plot.out=F)
PlotCurves(Fit1,plotlens=10:20,plot.out=F)
View(PlotCurves)
PlotCurves=function(fit,plotlens=NULL,Meshsize=NULL,rel.power=NULL,standardize=F,
plot.out=T,xlab="Length (cm)",ylab="Retention curve",...) {
s=selncurves(fit$rtype) #Get selection curve function
if(is.null(plotlens)) plotlens=fit$Data[,1]
if(is.null(Meshsize)) Meshsize=fit$Meshsize
if(is.null(rel.power)) pwr=fit$rel.power
smatrix=outer(plotlens,Meshsize,s,fit$par)
smatrix=t(t(smatrix)*pwr)
if(standardize) smatrix=smatrix/max(smatrix)
#Plot propn retained if only two gears
if(plot.out){
if(length(Meshsize)==2) {
plot(plotlens,smatrix[,2],type="l",ylim=c(0,1),xlab=xlab,ylab=ylab,...)
abline(h=c(0.25,0.5,0.75),lty=3) }
else {
matplot(plotlens,smatrix,type="l",ylim=c(0,1),xlab=xlab,ylab=ylab,...) }
}
lensmatrix=cbind(plotlens,smatrix)
colnames(lensmatrix)=c("Length",paste0("Gear",1:length(Meshsize)))
if(plot.out) invisible(lensmatrix)
if(!plot.out) lensmatrix
}
PlotCurves(Fit1,plotlens=newdata,plot.out=F)
PlotCurves(Fit1,plotlens=lenseq,plot.out=F)
lenseq=30:54
PlotCurves(Fit1,plotlens=lenseq,plot.out=F)
PlotCurves(Fit1,plotlens=lenseq,plot.out=F)
lenseq=10:30
PlotCurves(Fit1,plotlens=lenseq,plot.out=F)
predict.SELECT=function(obj,newdata=NULL) {
if(!is.vector(newdata)) stop("Error: newdata must be a vector of lengths")
PlotCurves(obj,plotlens=newdata,plot.out=F) }
predict(Fit1)
predict.SELECT=function(obj,newdata=NULL) {
if(!is.null(newdata) & !is.vector(newdata))
stop("Error: newdata must be a vector of lengths")
PlotCurves(obj,plotlens=newdata,plot.out=F) }
predict(Fit1)
predict(Fit1,newdata=12:45)
predict(Fit1,newdata=5:30)
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R2/SELECT2.R")
selfFit1
summary(selfFit1)
summary(Fit1)
Estimates(Fit1)[]
Fit1[]
solve(Fit1$hessian)
sqrt(diag(solve(Fit1$hessian)))
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R2/SELECT2.R")
AIC.SELECt=function(obj) 3
AIC(Fit1)
AIC
Fit1
Fit1[]
logLik.SELECT=function(0bj) obj$logLik
logLik.SELECT=function(obj) obj$logLik
logLik(Fit1)
AIC(Fit1)
?AIC
Fit1$logLik
llhood=Fit1$logLik
llhood
attribute(llhood,"df")=2
attributes(llhood,"df")=2
?attributes
attributes(Stow.df)
attributes(llhood)
llhood
attr(llhood,"df")=2
llhood
attributes(llhood)
logLik.SELECT=function(obj) {
logLik=obj$logLik
attr(ogLik,"df")=length(obj$par)
class(ogLik)="logLik"
logLik }
logLik(Fit1)
logLik.SELECT=function(obj) {
logLik=obj$logLik
attr(logLik,"df")=length(obj$par)
class(logLik)="logLik"
logLik }
logLik(Fit1)
AIC(Fit1)
BIC(Fit1)
Fit1[]
ModelCheck(Fit1)
?deviance
View(ModelCheck)
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R2/SELECT2.R")
Fit1=SELECT2(Stow.df,var.names=V.names,q.names=sampfracs)
Fit1[]
logLik.SELECT=function(obj) {
logLik=obj$logLik
attr(logLik,"df")=length(obj$par)
attr(logLik,"nobs")=obj$npos
class(logLik)="logLik"
logLik }
LogLik(Fit1)
logLik(Fit1)
AIC(Fit1)
BIC(Fit1)
deviance(selfFit1)
selfFit1
AIC(selfFit1)
Fit1[]
deviance.SELECT=function(obj) 2*(obj$full.logLik-obj$logLik)
deviance(Fit1)
Fit1
deviance.SELECT=function(obj) obj$deviance
deviance(Fit1)
Fit1
selfFit1
summary(Fit1)
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R2/SELECT2.R")
#remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
#remotes::install_github("rbmillar/SELECT")
require(SELECT)
require(tidyverse)
require(selfisher)
Stow.df=read.csv("LgSq.csv",header=T) #343 rows
Stow.df=subset(Stow.df,total>0) #213 rows
Stow.df=transform(Stow.df,qratio=qcodend/qcover,
n=codend+cover,y=codend/(codend+cover))
#head(Stow.df)
v.names=c("lgth","cover","codend")
q.fracs=c("qcover","qcodend")
Tots.df=Raw2Tots(Stow.df,v.names,q.names=q.fracs)
Tots.df=transform(Tots.df,n=codend+cover,y=codend/(codend+cover))
#Using selfisher on totals
selfFit1=selfisher(y~lgth,data=Tots.df,total=n,haul=NULL)
summary(selfFit1)
#Using SELECT
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
Fit1[[]]
Fit1$Data
Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
#remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
#remotes::install_github("rbmillar/SELECT")
require(SELECT)
require(tidyverse)
require(selfisher)
SELECT=function(data,var.names,dtype="cc",stype="logistic",useTots=TRUE,
q.names=NULL,Meshsize=NULL,x0=NULL,rel.power=NULL,penalty.func=NULL,
verbose=NULL,control=list(maxit=10000,reltol=1e-8),Fit=TRUE) {
#SELECT.args=as.list(environment()) %>% discard(is.null)
if(typeof(var.names)!="character")
stop('SELECT errror message: \n Variable names must be character')
if(!is.null(q.names) & typeof(q.names)!="character")
stop('SELECT errror message: \n Scaling variable names must be character')
dtype=substr(dtype,1,2)
rtype=paste0(dtype,".",stype)
r=propncurves(rtype) #Get propn catch curve function
nGears=length(var.names)-1
GearNames=paste0("n",1:nGears)
Data=data[,var.names]
colnames(Data)=c("lgth",GearNames)
if(!is.null(q.names)) Data[,-1] = Data[,-1]/data[,q.names]
if(useTots) Data=Data %>% group_by(lgth) %>%
summarize(across(all_of(GearNames),sum)) %>% data.frame()
Counts=Data[,-1]
Const=mchoose(Counts,log=T) #Constant for log-likelihoods
designTypes=c("relative","covered codend","paired haul","paired haul")
design=designTypes[match(dtype,c("re","cc","ph","un"))]
if(!(dtype %in% c("re","cc","ph","un")))
stop('SELECT errror message: \ndesign must be one of "cc" (covered codend),
"ph" (paired haul), or "re" (relative - primarily for gillnets and hooks)')
rtype=paste0(dtype,".",stype)
if(stype %in% c("logistic","richards") & is.null(Meshsize)) Meshsize=c(0,1)
if(dtype=="un") Meshsize=c(1,1) #Arbitrary, since unrestricted
if(sum(sort(Meshsize)==Meshsize)!=length(Meshsize))
stop("Mesh size must be in ascending order")
if(is.null(rel.power) | dtype %in% (c("cc","ph","un")))
rel.power=rep(1,length(Meshsize))
if(is.null(penalty.func)) penalty.func=function(theta){0.0}
if(nGears!=length(Meshsize)) stop("Number of mesh sizes should be ",nGears)
if(is.null(x0)) x0=StartValues(rtype,Data)
#SELECT.args=list(Data=Data,rtype=rtype,Meshsize=Meshsize,x0=x0,
#                rel.power=rel.power,penalty.func=penalty.func)
#Calculate logliks at x0 and of saturated model
ll.init=Const-nllhood(theta=x0,Data,Meshsize,r,rel.power,penalty.func)
CountTotals=apply(Counts,1,sum,na.rm=TRUE)
npos=sum(CountTotals>0)
CountTotals=ifelse(CountTotals==0,Inf,CountTotals)
CountPropns=Counts/CountTotals
ll.fullfit=Const+sum(Counts[Counts>0]*log(CountPropns[Counts>0]),na.rm=TRUE)
if(is.null(verbose)) cat("Log-likelihood is",ll.init,"at x0=",round(x0,2),"\n")
if(is.null(verbose)) cat("Saturated log-likelihood is",ll.fullfit,"\n")
if(!Fit) {
if(is.null(verbose)) cat("SELECT model fitted at x0 - no optimization: \n")
control$maxit=0
#Hessian is not evaluated at x0 when maxit=0, so set hessian=F
fit=optim(x0,nllhood,Data=Data,Meshsize=Meshsize,r=r,rel.power=rel.power,
penalty.func=penalty.func,hessian=F,control=control)
fit$par=x0 #Quirk of optim with maxit=0 is that pars are set to zero
fit$hessian=matrix(NA,length(x0),length(x0)) }
if(Fit) {
if(is.null(verbose))
cat("Fitting SELECT model with",stype,"selection curves to",design,"data.\n")
fit=optim(x0,nllhood,Data=Data,Meshsize=Meshsize,r=r,rel.power=rel.power,
penalty.func=penalty.func,hessian=T,control=control) }
fit$value=fit$value-Const
fit=fit[names(fit) %in% c("counts", "message") == FALSE]
Dev=2*(ll.fullfit+fit$value)
if(is.null(verbose)) {
cat(paste0("Convergence code ",fit$convergence,
": Optimizer has ",ifelse(fit$convergence==0,"","*NOT*"),"converged\n"))
cat("Pars=",fit$par,", Deviance=",Dev,", #len classes=",npos,"\n") }
z=c(Call=match.call(),fit,deviance=Dev,SELECT.args,npos=npos,
init.logLik=ll.init,full.logLik=ll.fullfit,logLik=-fit$value)
class(z)="SELECT"
return(invisible(z))
}
Stow.df=read.csv("LgSq.csv",header=T) #343 rows
Stow.df=subset(Stow.df,total>0) #213 rows
Stow.df=transform(Stow.df,qratio=qcodend/qcover,
n=codend+cover,y=codend/(codend+cover))
#head(Stow.df)
v.names=c("lgth","cover","codend")
q.fracs=c("qcover","qcodend")
Tots.df=Raw2Tots(Stow.df,v.names,q.names=q.fracs)
Tots.df=transform(Tots.df,n=codend+cover,y=codend/(codend+cover))
#Using selfisher on totals
selfFit1=selfisher(y~lgth,data=Tots.df,total=n,haul=NULL)
summary(selfFit1)
#Using SELECT
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/HELPER_FUNCTIONS.R")
mchoose=function(x,log=TRUE){
x=as.matrix(x)
if(ncol(x)==1) stop("x[] must have at least 2 columns")
rowN=apply(x,1,sum,na.rm=T)
const=0
for(i in 1:nrow(x)) const=const+lgamma(rowN[i]+1)-sum(lgamma(x[i,]+1),na.rm=T)
if (log) return(const)
else return(exp(const))
}
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
SELECT=function(data,var.names,dtype="cc",stype="logistic",useTots=TRUE,
q.names=NULL,Meshsize=NULL,x0=NULL,rel.power=NULL,penalty.func=NULL,
verbose=NULL,control=list(maxit=10000,reltol=1e-8),Fit=TRUE) {
SELECT.args=as.list(environment()) %>% discard(is.null)
if(typeof(var.names)!="character")
stop('SELECT errror message: \n Variable names must be character')
if(!is.null(q.names) & typeof(q.names)!="character")
stop('SELECT errror message: \n Scaling variable names must be character')
dtype=substr(dtype,1,2)
rtype=paste0(dtype,".",stype)
r=propncurves(rtype) #Get propn catch curve function
nGears=length(var.names)-1
GearNames=paste0("n",1:nGears)
Data=data[,var.names]
colnames(Data)=c("lgth",GearNames)
if(!is.null(q.names)) Data[,-1] = Data[,-1]/data[,q.names]
if(useTots) Data=Data %>% group_by(lgth) %>%
summarize(across(all_of(GearNames),sum)) %>% data.frame()
Counts=Data[,-1]
Const=mchoose(Counts,log=T) #Constant for log-likelihoods
designTypes=c("relative","covered codend","paired haul","paired haul")
design=designTypes[match(dtype,c("re","cc","ph","un"))]
if(!(dtype %in% c("re","cc","ph","un")))
stop('SELECT errror message: \ndesign must be one of "cc" (covered codend),
"ph" (paired haul), or "re" (relative - primarily for gillnets and hooks)')
rtype=paste0(dtype,".",stype)
if(stype %in% c("logistic","richards") & is.null(Meshsize)) Meshsize=c(0,1)
if(dtype=="un") Meshsize=c(1,1) #Arbitrary, since unrestricted
if(sum(sort(Meshsize)==Meshsize)!=length(Meshsize))
stop("Mesh size must be in ascending order")
if(is.null(rel.power) | dtype %in% (c("cc","ph","un")))
rel.power=rep(1,length(Meshsize))
if(is.null(penalty.func)) penalty.func=function(theta){0.0}
if(nGears!=length(Meshsize)) stop("Number of mesh sizes should be ",nGears)
if(is.null(x0)) x0=StartValues(rtype,Data)
#SELECT.args=list(Data=Data,rtype=rtype,Meshsize=Meshsize,x0=x0,
#                rel.power=rel.power,penalty.func=penalty.func)
#Calculate logliks at x0 and of saturated model
ll.init=Const-nllhood(theta=x0,Data,Meshsize,r,rel.power,penalty.func)
CountTotals=apply(Counts,1,sum,na.rm=TRUE)
npos=sum(CountTotals>0)
CountTotals=ifelse(CountTotals==0,Inf,CountTotals)
CountPropns=Counts/CountTotals
ll.fullfit=Const+sum(Counts[Counts>0]*log(CountPropns[Counts>0]),na.rm=TRUE)
if(is.null(verbose)) cat("Log-likelihood is",ll.init,"at x0=",round(x0,2),"\n")
if(is.null(verbose)) cat("Saturated log-likelihood is",ll.fullfit,"\n")
if(!Fit) {
if(is.null(verbose)) cat("SELECT model fitted at x0 - no optimization: \n")
control$maxit=0
#Hessian is not evaluated at x0 when maxit=0, so set hessian=F
fit=optim(x0,nllhood,Data=Data,Meshsize=Meshsize,r=r,rel.power=rel.power,
penalty.func=penalty.func,hessian=F,control=control)
fit$par=x0 #Quirk of optim with maxit=0 is that pars are set to zero
fit$hessian=matrix(NA,length(x0),length(x0)) }
if(Fit) {
if(is.null(verbose))
cat("Fitting SELECT model with",stype,"selection curves to",design,"data.\n")
fit=optim(x0,nllhood,Data=Data,Meshsize=Meshsize,r=r,rel.power=rel.power,
penalty.func=penalty.func,hessian=T,control=control) }
fit$value=fit$value-Const
fit=fit[names(fit) %in% c("counts", "message") == FALSE]
Dev=2*(ll.fullfit+fit$value)
if(is.null(verbose)) {
cat(paste0("Convergence code ",fit$convergence,
": Optimizer has ",ifelse(fit$convergence==0,"","*NOT*"),"converged\n"))
cat("Pars=",fit$par,", Deviance=",Dev,", #len classes=",npos,"\n") }
z=c(Call=match.call(),fit,deviance=Dev,SELECT.args,npos=npos,
init.logLik=ll.init,full.logLik=ll.fullfit,logLik=-fit$value)
class(z)="SELECT"
return(invisible(z))
}
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
Fit1$data
Fit2$Data
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
unlist(Fit1)
unlist(list(a="a",b="asdf"))
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
list(a=1,b=2)
x=list(a=1,b=2)
list(c="g",x)
c(c="g",x)
c(c="g",x,M=matrix(0,2,2))
list(c="g",x,M=matrix(0,2,2))
list(c(c="g",x),M=matrix(0,2,2))
xx=list(c(c="g",x),M=matrix(0,2,2))
xx$c
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs); Fit1[]
Fit1$data
Fit1$Tots
print(Fit1)
Fit1
Fit1[[]]
Fit1$data
Fit1[]
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
Fit1[]
Fit1[]
Dble.boot
bootSELECT
permSELECT
Fit1$var.names
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/BOOTSTRAP&PERMUTATION.R")
bootCoefs=function(data) {
coef( SELECT(data,var.names=v.names,q.names=q.fracs,verbose=F) ) }
bootCoefs(Stow.df) #Check
bootCoefs=function(data) {
coef( SELECT(data,var.names=v.names,q.names=q.fracs,verbose=F) ) }
bootCoefs(Stow.df) #Check
BootOut=bootSELECT(Fit1,bootCoefs,haul="Haul",nsim=40)
require(data.table)
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
coef(Fit1)
summary(Fit1)
Stow.df
#19 covered-codend deployments, and 18 lengthclasses (6 to 23mm)
Stow.df=read.csv("LgSq.csv",header=T) #343 rows
Stow.df=subset(Stow.df,total>0) #213 rows
Stow.df=transform(Stow.df,qratio=qcodend/qcover,
n=codend+cover,y=codend/(codend+cover))
#head(Stow.df)
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
coef(Fit1)
summary(Fit1)
Fit1$data
summary.SELECT
summary(Fit1)
Estimates(Fit1)
ModelCheck(Fit1)
source("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT/R/FIT_FUNCTIONS.R")
#Using selfisher on totals
selfFit1=selfisher(y~lgth,data=Tots.df,total=n,haul=NULL)
summary(selfFit1)
#Using SELECT
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
coef(Fit1)
summary(Fit1)
plot(Fit1)
#Create a function to return L50 and SR
bootCoefs=function(data) {
coef( SELECT(data,var.names=v.names,q.names=q.fracs,verbose=F) ) }
bootCoefs(Stow.df) #Check
BootOut=bootSELECT(Fit1,bootCoefs,haul="Haul",nsim=40)
apply(BootOut,2,sd)
Fit1[]
#remotes::install_local("S:/Russell_SSD/ACTIVE/CurrentWork/RPackages/SELECT",force=T)
#remotes::install_github("rbmillar/SELECT")
require(SELECT)
require(selfisher)
#require(data.table)
require(tidyverse)
#19 covered-codend deployments, and 18 lengthclasses (6 to 23mm)
Stow.df=read.csv("LgSq.csv",header=T) #343 rows
Stow.df=subset(Stow.df,total>0) #213 rows
Stow.df=transform(Stow.df,qratio=qcodend/qcover,
n=codend+cover,y=codend/(codend+cover))
#head(Stow.df)
v.names=c("lgth","cover","codend")
q.fracs=c("qcover","qcodend")
Tots.df=Raw2Tots(Stow.df,v.names,q.names=q.fracs)
Tots.df=transform(Tots.df,n=codend+cover,y=codend/(codend+cover))
#Using selfisher on totals
selfFit1=selfisher(y~lgth,data=Tots.df,total=n,haul=NULL)
summary(selfFit1)
#Using SELECT
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
coef(Fit1)
summary(Fit1)
plot(Fit1)
#Create a function to return L50 and SR
bootCoefs=function(data) {
coef( SELECT(data,var.names=v.names,q.names=q.fracs,verbose=F) ) }
bootCoefs(Stow.df) #Check
BootOut=bootSELECT(Fit1,bootCoefs,haul="Haul",nsim=40)
apply(BootOut,2,sd)
#19 covered-codend deployments, and 18 lengthclasses (6 to 23mm)
Stow.df=read.csv("LgSq.csv",header=T) #343 rows
Stow.df=subset(Stow.df,total>0) #213 rows
Stow.df=transform(Stow.df,qratio=qcodend/qcover,
n=codend+cover,y=codend/(codend+cover))
#head(Stow.df)
v.names=c("lgth","cover","codend")
q.fracs=c("qcover","qcodend")
Tots.df=Raw2Tots(Stow.df,v.names,q.names=q.fracs)
Tots.df=transform(Tots.df,n=codend+cover,y=codend/(codend+cover))
#Using selfisher on totals
selfFit1=selfisher(y~lgth,data=Tots.df,total=n,haul=NULL)
summary(selfFit1)
#Using SELECT
Fit1=SELECT(Stow.df,var.names=v.names,q.names=q.fracs)
coef(Fit1)
summary(Fit1)
plot(Fit1)
#Create a function to return L50 and SR
bootCoefs=function(data) {
coef( SELECT(data,var.names=v.names,q.names=q.fracs,verbose=F) ) }
bootCoefs(Stow.df) #Check
BootOut=bootSELECT(Fit1,bootCoefs,haul="Haul",nsim=400)
apply(BootOut,2,sd)
PkgName="SELECT"
#Create package folder structure (and opens 2nd RStudio for the project)
#usethis::create_package(PkgName)
setwd(paste0("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/",PkgName))
BootOut=bootSELECT(Fit1,bootCoefs,haul="Haul",nsim=400)
roxygen2::roxygenise() #or devtools::document()
#To load local package
devtools::install( paste0("T:/Russell_SSD/ACTIVE/CurrentWork/RPackages/",PkgName) )
